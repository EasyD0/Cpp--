---
创建时间: 2023-09-12, 16:52:48
更新时间: 2024-09-25, 20:08:02
tags:
  - cpp
链接:
---
## 1 基础
### 1.1 表达式的概念
**运算对象**: 即可参与运算的对象.

表达式由 一些 **运算对象** 组成, 对表达式求值得到一个 结果
字面值和变量是最简单的表达式, 它们的结果就是本身.(但一般要加括号)
用运算符将多个 运算对象组合 就能得到复杂表达式

**举例**
先定义一个数`int a=1;`
现在可以说 `(a)` 是一个表达式, `a+1` 是一个表达式, `(1)` 是表达式
### 1.2 运算符概念介绍
###### 重载运算符
当运算符用于类对象时,可以自定义运算符,即重载

> [[§14. 重载运算符, 类型转换]]

### 1.3 表达式优先级
略
### 1.4 左值和右值
###### 左值和右值的概念
- 该概念来自 c 语言. 在 c 中, 左值可在赋值左边, 右值只能在右边.  但在 c++中该概念更复杂了.
- 表达式要么是**左值** 要么是 **右值**
- 对象作为右值时, 用的是它的内容; 作为左值时, 用的是它的身份(内存中的位置)
- **一般的, 在需要右值时, 可以用左值替代, 反之则不行**(特殊情况, 比如对象移动时, 必须要右值引用)
- 当左值被 用于右值时, 用的是它的内容 而非 身份

***一些特殊例子如下:***
- 取地址运算`&`  作用在左值对象上, 得到指针是右值

```cpp
int *a=&b; // &b是右值
```

- 赋值运算符`=`, 它的左边应该是一个 非常量左值. 结果也是左值, 这样可连续赋值

```cpp
int a,b; a=b=1;
```

- 内置类型和迭代器(数组等)的递增`++`,递减`--`, 它们的运算结果是左值

参考书上更详细:
![[Pasted image 20240227102955.png|800]]

###### 左值右值的理解
- 右值生命周期**通常**仅限于当前语句或表达式
- 右值可以是字面值、临时对象或移动语义中产生的临时对象
- 通俗地理解, 若一个表达式*可以对它取地址*, 则为左值, 否则为右值

比如 `int *a = &x;` , 这里的 `&x` 就是 `x` 的地址, 它作为右值, 只在这一条语句中起作用. 语句结束后它不在程序中了.

***例子***

```cpp
void foo(int &a){cout<<1;}
void foo(int &&a){cout<<2;}

int main(){
	int &&value = 5; //声明并定义一个右值引用类型
	foo(value);      //这里调用时, value作为左值. 返回结果为1
}
```

```ad-note
左值还是右值, 不是以定义时为标准的.
直接定义并初始化一个右值引用 是很少见的.
```

###### 左值, 右值, 纯右值, 将亡值

> 现代 c++教程__欧长坤

- 左值: 表达式结束后, 依然存在的持久对象.
- 右值: 表达式结束后, 不再存在的临时对象.
- 右值可分为 纯右值(pure rvalue, prvalue)和将亡值(expiring value, xvalue)
	- 纯右值
		- 纯粹字面量, 如 `10`, `true` 等
		- 表达式结果相当于字面量 或 匿名临时对象, 如 `1+2`
		- 当函数返回一个*临时对象*时, 这个临时对象 是纯右值
	- 将亡值: 即将被销毁、却能够被移动的值.
		- 将亡值是右值, 同时也是*泛左值*(glvalue)
		- 具有名称标识

![[Pasted image 20240619195359.png|300]]
***例子:***

```cpp
std::vector<int> fun(){
	std::vector<int> temp {1,2,3,4};
	return temp;
}

int main(){
	auto v = fun();
}
```

在 `auto v = fun();` 中, 函数返回的是临时 vector 对象, 表达式 `fun()` 是纯右值
那个返回的临时对象, 被 v 拷贝后, 将立刻销毁.

```ad-note
当称术语 "值"的时候, 一般是指 *泛左值*
当称术语 "对象" 时, 一般是指 *纯右值*
```

###### 如何区分 将亡值和 纯右值?
- 将亡值具有身份信息 (因此称为泛左值), 同时也可以被移动, 即使它所在的语境可能不发生移动.
- 而*纯右值没有标识符*, 它只是字面值, 临时量等.
***例子***

```cpp
int x = 1; //x是左值
static_cast<int &&>(x); //该表达式的结果是一个 int &&, 它是可移动的, 它是将亡值;

int &&y = std::move(x);  // std::move(x) 是一个将亡值 表达式
//虽然 int没有移动构造函数, 但 std::move(x) 是一个可移动的值 


int f(){return 1;}  //函数返回的1是纯右值
int && x = f(); // f() 是临时量, 也是纯右值, x是左值

int &&y = x; // !非法 x是左值, 不能被移动.
```

```ad-note
为什么 `x+1` 是纯右值, 而 `std::move(x)` 是将亡值?
- `std::move(x)`实际上调用`static_cast<int &&>(x)`
	- `std::move(x)` 并没有创建一个新的值或对象，它只是把现有的 `x` 转换为一个**右值引用**, 并返回这个右值引用.
	- 因此它的结果是`x`的右值引用, 它是一个引用, 是一个标识符
	- 当确实发生移动时, x的值将被移动, 因为`std::move(x)`带有标识信息.
- 而`x+1`它创建了一个临时量
	- 对它的任何操作都不影响x本身, 因为`x+1`不带有`x`的标识信息.
```

###### 将变量视为左值
变量可以看作只有一个运算对象, 且没有任何运算表达式
此时变量表达式都是左值的.

###### 引用类型作为函数参数的区别
以 `int` 类型的引用复合类型举例, 当它作为函数形参类型时, 有如下区别

| 形参              | 类型     | 可传入的实参类型 | 备注           |
| --------------- | ------ | -------- | ------------ |
| `int &a`        | 左值引用   | 左值       |              |
| `int &&a`       | 右值引用   | 右值       | 可接受字面量       |
| `const int &a`  | 左值常量引用 | 左值或右值    | 不能在函数体内修改该参数 |
| `const int &&a` | 右值常量引用 | 常量右值表达式  | 几乎不使用        |

###### 拷贝语义和移动语义
拷贝语义: 不会修改（清理）原值的内容
移动语义: 可能修改（清理）原值的内容, 具体取决于移动构造函数的定义

```cpp
vector<int> x{1,2,3};
vector<int> y(std::move(x)); //将调用移动构造函数
// 最后y得到x的内容, x清空
```

###### 为何要引入右值引用?
- 高效处理临时对象: 使得临时对象可以被"移动"而不是"复制"
- 配合移动语义使用
- 避免不必要的拷贝, 使用 `std::move()` 以及移动语义.
- 完美转发, 配合 `std::forward()`
## 2 sizeof运算
`sizeof` 返回表达式或类型名称 所占的字节数

```cpp
int a=1,b=1;

cout<< sizeof(a+b); // 返回表达式 a+b 所占的字节数
cout<< sizeof(int); // 返回类型名称 int 所占的字节数
```

###### sizeof可以返回类成员的占用
- 即使类成员是 `private` 的, `sizeof` 仍然可用
- 因为 `sizeof` 不直接访问成员, 而是访问它的类型
- `sizeof` 无需具体的对象, 就能获取类成员的大小

```cpp
class A{
private: 
	int num;
};

cout<< sizeof(A::num); //直接查询 private成员的大小
```

###### sizeof具体的情况
- 当作用于引用类型, 返回被引用对象的占用
- 对于*指针*, 得到指针本身的占用
- 对于解引用的指针, 得到指向对象的大小
- 对于*数组*, 得到整个数组的占用空间. 并不会把数组视为指针
- 对于容器, 比如 `string` 和 `vector`, 得到该类型固定部分的大小, 不计算容器的元素占用的空间

```ad-note
- `sizeof` 可以用于计算数组长度, 只要先计算整体大小, 然后除以单个元素的大小
- `sizeof()` 返回的是**常量表达式**, 它能用于声明数组大小
```

## 3 类型转换
### 3.1 隐式转换
###### 何时发生隐式类型转换?
- 条件语句中, 非布尔转为布尔型
- 初始化时, 初始值变为变量的类型.
- 赋值语句中, 右侧的对象转换为左侧类型
- 算术/关系运算中, 有多种类型参与时, 会转换为同一种
- 函数调用时, 可能发生类型转换
###### 算术转换
- 含义: 将一种算术 转换为 另一种算术转换
- 多个算术类型的对象 参与运算时, 转换为最宽的类型
#### 3.1.2 其他隐式转换
###### 数组转指针
大多数表达式中, 数组自动转为 它头部的指针
但是,当被用于 `decltype`推断、取地址`&`、`sizeof`、`typeid`等运算时, 则不会转换
###### 指针转换
- `0`和`nullptr`能转换为任何类型的指针
- 指向非常量 的指针, 都能转为`void*`类型
- 任意指针, 都能转为转为`const void*`
###### 转为bool型
- 指针或算术类型, 可转为`bool`
- 当值不为0时, 转为`true`, 否则为`false`
- 因此可以通过`if`判断 指针是否为空
###### 转为常量

### 3.2 显式转换
#### 现代c++的强制类型转换
###### 命名的强制类型转换
`cast-name<type>(expr);`

- type是目标类型, 如果为引用类型, 则结果是**左值**
- expr是被转换的表达式
- cast-name有四种, c++20有5种
###### static-cast
- 可用于大部分类型转换, 只要类型已经定义了.
- 不会执行运行时的类型检查
- 不能修改**底层const属性**

***例子1***

```cpp
double d;
void *p = &d;
double *dp = static_cast<double* >(p); 
```

当转换回原来的类型时, 应保证 指针的值不变, 也就是指向的地址不发生改变.

***例子2***

```cpp
struct B {
	virtual ~B()=default;
};

struct D : public B {
	virtual ~D()=default;
};

int main (){
	B *pb = new D();
	D *pd = static_cast<D*>(pb);

	B *pb2 = new B();
	D *pd2 = static_cast<D*>(pb2); //危险
}
```

- 这可能发生危险, 因为不检查类型, 而是直接按内存分布来转换. 指针 `pd2` 的范围可能指向非法内存.
###### dynamic-cast
- 和 `static_cast` 相比, 支持在运行时类型识别
- 通常用于类类型 继承关系中的 指针或引用的转换

```ad-tip
何时使用 `static_cast`?
- 当确定代码安全时, 可以使用 `static_cast`, **速度更快**
- 否则使用 `dynamic-cast`
```

###### const-cast
- 只用于修改 对象的 **底层const属性**
	- 这一点和 static_cast 正好相反

```cpp
const int *p1;
int *p2 =const_cast<int * >(p1); // 将底层const删除了, 但通过p2修改其指向的内容, 行为是未定义的

const char *p3;
string s = const_cast<string>(p3) //出错, 只能修改const属性
```

###### reinterpret-cast
- 比 `static_cast` 更危险, **即使类型不相关**, 也能执行转换
- 可以将 `void*` 转换为其他类型的指针

```cpp
int main() {
  int a = 1;
  int *p = &a;
  std::cout << p << std::endl;
  long p2 = reinterpret_cast<long>(p);
  std::cout << p2 << std::endl;
}
```

###### std::bit_cast
由 c++20引入
- 这是定义在*标准库*中的**函数模板**, 并非语言特性
- 转换要求是 前后类型的大小相同, 并都可拷贝
- 它转换的行为实际上是拷贝,  创建一个新类型的对象, 并按 bit 拷贝自原对象.
- 它的*返回值*就是 目标类型的对象.

```cpp

```

#### 旧式的强制类型转换
###### 两种旧版的转换
- 函数形式的: `type (expr)
- C语言风格的: `(type) expr`

```cpp
int a=1;
double b = double(a);
double c = (double)a;
```

## 一些特殊表达式
### noexcept 说明符和运算符
###### noexcept 说明符
noexcept 规范是函数类型的一部分，并且可以作为任何函数声明的一部分出现
C++ 中的每个函数要么不抛出异常，要么可能抛出：
***句法1***

```cpp
noexcept(常量布尔表达式)
noexcept   //单独使用 等价于 noexcept(true)
throw()    // 等价于第二条, 被弃用
```

- 只要表达式的计算结果为 `true` ，则*声明*该函数不抛出任何异常
- 然而这只是一种声明, 实际上仍然有可能抛出异常
***例子***

```cpp
void mayThrow() noexcept {
    throw std::runtime_error("This will cause terminate");
}
```

###### noexcept 运算符
***句法***

```cpp
noexcept(任意表达式)
```

- noexcept 运算符执行编译时检查
- 结果是一个 `bool` 类型的表达式 `exp`
- 如果 `exp` *声明不引发任何异常*，则返回 `true`
	- 注意如果 `exp` 声明不引发任何异常, 但实际引发异常, 那么结果依然是 `true`

***例子***

```cpp
std::cout<<noexcept(true)<<noexcept(false);
//结果都是1, 因为true和false都合法
```

```cpp
void mayThrow() noexcept {
    throw std::runtime_error("This will cause terminate");
}

bool isNoexcept = noexcept(mayThrow());  //编译时检查，返回 false
```

- 这个例子能通过编译并正常运行, 只要不真的执行 `mayThrow` 函数
- 由于 `mayThrow()` *声明不会抛出异常*, 因此结果为 `true`
	- 这是因为 `noexcept` 表达式也只是检查作用, 不能实际知道它是否抛出异常
	- `mayThrow` 已经声明了 `noexcept`, 那么编译器只能感知到这一步.

###### 双层 noexcept 的作用
**作用:** 让函数和 `表达式` 具有相同的异常说明

```cpp
template<typename T> 
void func noexcept(noexcept(表达式)) {}
```

- 双层 `noexcept` 一般用于模板中, `表达式` 的值和模板实参有关.
- 外面那层是*说明符*, 而里面那层是*运算符*

***下面举例说明***
**使用双层**
- 如果类型 `T1` 使得表达式合法/不抛出异常, 那么 `noexcept(表达式)` 返回 `true`, 从而整体结果为 `noexcept(true)`, 表明函数不抛出异常
- 如果类型 `T1` 使得表达式不合法/可能抛出异常, 那么 `noexcept(表达式)` 返回 `false`, 从而整体结果为 `noexcept(false)`, 表明函数可能抛出异常

**使用单层**
- 他只是一个 `noexcept` 表达式, 不能用于声明函数的异常属性

***例子***

```cpp
template <class T>
void f1() noexcept(T()) {}  //1

template <class T>
void f2() noexcept(noexcept(T())) {} //2

struct A{
	A() noexcept {}
};

int main(){
	f1<A>(); //发生错误
	f2<A>();  //正确
	f1<bool>(); //ok
}
```

1. `noexcept(T())`
	- 如果类型 `T` 有默认构造函数, 且 `T()` 不抛出异常, `T()` 将得到一个临时对象, `noexcept` 在此时的用法是 *说明符*, 这不符合语法规定
	- 如果 `T` 是 `bool` 类型, 那么 `bool()` 将产生一个临时 bool 量 `false`, `noexcept(false)` 说明了函数可能抛出异常.
2. `noexcept(noexcept(T()))` 
	- `noexcept(T())` 是一个运算表达式, 当且仅当 `T()` 不抛出异常时, 表达式结果为 `true`
	-  当且仅当 `T()` 不抛出异常时, 函数 `f2` 不抛出异常.
